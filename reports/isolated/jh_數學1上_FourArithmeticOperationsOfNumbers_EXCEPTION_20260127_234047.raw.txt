```python
def generate(level=1, **kwargs):
    import random
    from fractions import Fraction

    # Step 1: Generate necessary variables based on MASTER_SPEC entities and constraints
    operand_int = random.randint(-50, -1) if random.random() < 0.5 else random.randint(1, 50)
    operand_fraction = Fraction(random.randint(-20, -1), random.randint(2, 20)) if random.random() < 0.5 else Fraction(random.randint(1, 20), random.randint(2, 20))
    while operand_fraction.denominator > 20:
        operand_fraction = Fraction(random.randint(1, 20), random.randint(2, 20))
    operand_decimal = round(Fraction(random.uniform(-20, -1) if random.random() < 0.5 else random.uniform(1, 20)), 1) if random.random() < 0.5 else round(Fraction(random.uniform(-20, -1) if random.random() < 0.5 else random.uniform(1, 20)), 2)
    while operand_decimal.denominator > 20:
        operand_decimal = round(Fraction(random.uniform(1, 20)), 1) if random.random() < 0.5 else round(Fraction(random.uniform(1, 20)), 2)

    operators = ['+', '-', '*', '/']
    operator1 = random.choice(operators)
    while operator1 in ('*', '/') and (operand_int == 0 or operand_fraction.numerator == 0 or operand_decimal.numerator == 0):
        operator1 = random.choice(operators)
    operator2 = random.choice(operators)
    while operator2 in ('*', '/') and (operand_int == 0 or operand_fraction.numerator == 0 or operand_decimal.numerator == 0):
        operator2 = random.choice(operators)

    # Step 2: Execute calculations based on MASTER_SPEC construction
    if level == 1:
        num_operands = 3
        bracket_type = random.choice(['none', 'left_group', 'right_group'])
        operands = [operand_int, operand_fraction, operand_decimal]
        operators = [operator1, operator2]

        if bracket_type == 'left_group':
            temp_res = eval(f"{operands[0]} {operators[0]} {operands[1]}")
            final_result = eval(f"{temp_res} {operators[1]} {operands[2]}")
        elif bracket_type == 'right_group':
            temp_res = eval(f"{operands[1]} {operators[1]} {operands[2]}")
            final_result = eval(f"{operands[0]} {operators[0]} {temp_res}")
        else:
            if operators[0] in ('*', '/') or operators[1] in ('*', '/'):
                temp_res = eval(f"{operands[0]} {operators[0]} {operands[1]}")
                final_result = eval(f"{temp_res} {operators[1]} {operands[2]}")
            else:
                temp_res = eval(f"{operands[0]} {operators[0]} {operands[1]}")
                final_result = eval(f"{temp_res} {operators[1]} {operands[2]}")

    # Step 3: Build the question LaTeX using fmt_num and op_latex
    if level == 1:
        q_parts = []
        for i in range(len(operands)):
            q_parts.append(fmt_num(operands[i]))
            if i < len(operators):
                q_parts.append(op_latex[operators[i]])

        if bracket_type == 'left_group':
            q_str = f"({q_parts[0]} {q_parts[1]} {q_parts[2]}) {q_parts[3]} {q_parts[4]}"
        elif bracket_type == 'right_group':
            q_str = f"{q_parts[0]} {q_parts[1]} ({q_parts[2]} {q_parts[3]} {q_parts[4]})"
        else:
            q_str = " ".join(q_parts)

    # Step 4: Format the answer to pure numeric format
    a = str(final_result) if final_result.denominator == 1 else f"{final_result.numerator}/{final_result.denominator}"

    # Step 5: Return standard format
    return {
        'question_text': clean_latex_output(q_str),
        'correct_answer': a,
        'answer': a,
        'mode': 1
    }
```