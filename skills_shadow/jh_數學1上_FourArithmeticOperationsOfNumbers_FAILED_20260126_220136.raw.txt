```python
def generate(level=1, **kwargs):
    # [Step 1] 模板選擇
    template = random.choice(['sequential_mixed_arithmetic_operations', 'distributive_property_application'])
    
    if template == 'sequential_mixed_arithmetic_operations':
        # [Step 2] 變數生成
        num_terms = random.randint(3, 4)
        term_types = [random.choice(['integer', 'fraction', 'mixed_number', 'decimal']) for _ in range(num_terms)]
        operator_sequence = [random.choice(['+', '-', '*', '/']) for _ in range(num_terms - 1)]
        has_parentheses = random.choice([True, False])
        
        terms = []
        for term_type in term_types:
            if term_type == 'integer':
                term = Fraction(random.randint(-100, 100))
                while term == 0:
                    term = Fraction(random.randint(-100, 100))
            elif term_type == 'fraction':
                num = random.randint(-50, 50)
                den = random.randint(2, 20)
                while num == 0 or den == 0:
                    num = random.randint(-50, 50)
                    den = random.randint(2, 20)
                term = Fraction(num, den)
            elif term_type == 'mixed_number':
                int_part = random.randint(-10, 10)
                while int_part == 0:
                    int_part = random.randint(-10, 10)
                num = random.randint(1, operand_mixed_den - 1)
                den = random.randint(2, 15)
                while num == 0 or den == 0 or gcd(num, den) != 1:
                    num = random.randint(1, operand_mixed_den - 1)
                    den = random.randint(2, 15)
                term = Fraction(int_part * den + num, den)
            elif term_type == 'decimal':
                decimal_value = round(random.uniform(-100, 100), 2)
                term = Fraction(str(decimal_value))
        
        # [Step 3] 運算
        result = terms[0]
        for i in range(num_terms - 1):
            if operator_sequence[i] == '/':
                while terms[i + 1] == 0:
                    terms[i + 1] = Fraction(random.randint(-50, 50))
            result = operators[operator_sequence[i]](result, terms[i + 1])
        
        # [Step 4] 題幹
        q_parts = []
        for i in range(num_terms):
            if term_types[i] == 'mixed_number':
                int_part = abs(terms[i].numerator) // terms[i].denominator
                frac_part = Fraction(abs(terms[i].numerator) % terms[i].denominator, terms[i].denominator)
                q_parts.append(f"{int_part} \\frac{{{fmt_num(frac_part.numerator)}}}{{{fmt_num(frac_part.denominator)}}}")
            else:
                q_parts.append(fmt_num(terms[i]))
        
        for i in range(num_terms - 1):
            q_parts.insert(i * 2 + 1, f" {op_latex[operator_sequence[i]]} ")
        
        if has_parentheses:
            paren_pos = random.randint(0, num_terms - 2)
            q_parts[paren_pos * 2] = '(' + q_parts[paren_pos * 2]
            q_parts[paren_pos * 2 + 3] += ')'
        
        q = ' '.join(q_parts)
        
        # [Step 5] 清洗
        q = clean_latex_output(q)
        
        # [Step 6] 答案
        a = fmt_num(result)
        
        # [Step 7] 清洗變數名
        if isinstance(a, str) and "=" in a:
            a = a.split("=")[-1].strip()
    
    elif template == 'distributive_property_application':
        # [Step 2] 變數生成
        common_factor = Fraction(random.randint(-100, 100))
        while common_factor == 0:
            common_factor = Fraction(random.randint(-100, 100))
        
        term1 = Fraction(random.randint(-100, 100))
        while term1 == 0:
            term1 = Fraction(random.randint(-100, 100))
        
        term2 = Fraction(random.randint(-100, 100))
        while term2 == 0 or term2 == term1:
            term2 = Fraction(random.randint(-100, 100))
        
        inner_operator = random.choice(['+', '-'])
        
        # [Step 3] 運算
        result = (term1 * common_factor) + (term2 * common_factor)
        simplified_result = (term1 + term2) * common_factor
        
        assert result == simplified_result, "分配律驗證失敗"
        
        # [Step 4] 題幹
        q = f"{fmt_num(term1)} \\op_latex(*) {fmt_num(common_factor)} \\op_latex({inner_operator}) {fmt_num(term2)} \\op_latex(*) {fmt_num(common_factor)}"
        
        # [Step 5] 清洗
        q = clean_latex_output(q)
        
        # [Step 6] 答案
        a = fmt_num(result)
        
        # [Step 7] 清洗變數名
        if isinstance(a, str) and "=" in a:
            a = a.split("=")[-1].strip()
    
    # [Step 8] 回傳
    return {
        'question_text': q,
        'correct_answer': a,
        'answer': a,
        'mode': 1
    }
```