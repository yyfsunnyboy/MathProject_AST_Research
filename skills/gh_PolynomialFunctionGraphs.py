import random
import matplotlib.pyplot as plt
import numpy as np
import uuid
import os
import re

# Ensure the directory exists for storing plots
PLOT_DIR = 'static/generated_plots'
os.makedirs(PLOT_DIR, exist_ok=True)

def generate(level=1):
    """
    生成多項式函數圖形特性相關題目。
    要求學生判斷函數圖形與x軸交點、以及滿足f(x)>0, f(x)<0, f(x)>=0, f(x)<=0 的區間。
    """
    # Level 1 typically covers degrees 1 to 4 with distinct real roots.
    degree = random.randint(1, 4) 
    
    # Generate distinct roots within a reasonable range (e.g., -5 to 5)
    # The number of roots equals the degree for simplicity (all distinct real roots).
    # `random.sample` ensures distinct roots.
    roots = sorted(random.sample(range(-5, 6), degree))

    # Determine the leading coefficient's sign for end behavior (+1 for up-right, -1 for down-right)
    leading_coeff_sign = random.choice([-1, 1]) 
    
    # Construct the polynomial function as a callable.
    # f(x) = a_n * (x - r1) * (x - r2) * ... * (x - rn)
    def polynomial_func(x_val):
        y_val = float(leading_coeff_sign) # Use float to prevent potential integer overflow
        for r in roots:
            y_val *= (x_val - r)
        return y_val

    # Generate plot using Matplotlib
    fig, ax = plt.subplots(figsize=(8, 6))

    # Define x-range for plotting, extending slightly beyond the roots for end behavior visualization
    x_min_plot = (roots[0] - 2) if roots else -7
    x_max_plot = (roots[-1] + 2) if roots else 7
    
    # Adjust range to ensure sufficient visual representation, especially for low degrees or roots near 0
    if degree == 1 and roots[0] == 0:
        x_min_plot, x_max_plot = -5, 5
    elif degree == 2 and roots[0] == 0 and roots[1] == 0: # Case for repeated root at 0, f(x) = ax^2
        # This specific case (non-distinct roots) is not generated by `random.sample`,
        # but added as a safeguard or if `roots` generation logic changes.
        x_min_plot, x_max_plot = -5, 5
    elif degree > 1 and len(roots) > 0:
        # If roots are all positive or all negative, ensure some negative/positive x-axis coverage
        if all(r >= 0 for r in roots):
            x_min_plot = min(x_min_plot, -2)
        elif all(r <= 0 for r in roots):
            x_max_plot = max(x_max_plot, 2)

    x_vals = np.linspace(x_min_plot, x_max_plot, 500)
    y_vals = [polynomial_func(x) for x in x_vals]

    # Plot the function line
    ax.plot(x_vals, y_vals, color='blue', linewidth=2)

    # Highlight x-axis intercepts (roots) with red circles
    ax.plot(roots, [0]*len(roots), 'ro', markersize=8, label='x-intercepts')

    # Draw x and y axes for reference
    ax.axhline(0, color='gray', linestyle='--', linewidth=0.8)
    ax.axvline(0, color='gray', linestyle='--', linewidth=0.8)

    # Add grid, labels, and title
    ax.grid(True, linestyle=':', alpha=0.7)
    ax.set_xlabel('$x$')
    ax.set_ylabel('$f(x)$')
    
    # Dynamic y-axis limits with padding for better visualization of peaks/valleys
    y_min_plot, y_max_plot = min(y_vals), max(y_vals)
    y_range = y_max_plot - y_min_plot
    if y_range == 0: # Handle cases where y is constant (e.g., f(x)=0 or f(x)=C), though not typically generated
        ax.set_ylim(y_min_plot - 1 if y_min_plot == 0 else y_min_plot - abs(y_min_plot)*0.2 - 1,
                    y_max_plot + 1 if y_max_plot == 0 else y_max_plot + abs(y_max_plot)*0.2 + 1)
    else:
        ax.set_ylim(y_min_plot - y_range * 0.15, y_max_plot + y_range * 0.15)
    
    ax.set_title(f'Graph of a {degree}rd-degree polynomial function $f(x)$', fontsize=14)
    
    plt.tight_layout()

    # Save the plot to the specified directory
    filename = f"gh_PolynomialFunctionGraphs_{uuid.uuid4().hex}.png"
    filepath = os.path.join(PLOT_DIR, filename)
    plt.savefig(filepath)
    plt.close(fig) # Close the plot to free up memory

    # Create an HTML <img> tag to embed the plot in the question text
    img_tag = f"<img src='/static/generated_plots/{filename}' alt='Polynomial Function Graph'>"

    question_text = f"已知多項式函數 $f(x)$ 的圖形如右，請判斷：<br>{img_tag}<br>"
    question_text += "(1) 滿足 $f(x)=0$ 的實數 $x$。<br>"
    question_text += "(2) 滿足 $f(x)>0$ 的實數 $x$。<br>"
    question_text += "(3) 滿足 $f(x)<0$ 的實數 $x$。<br>"
    question_text += "(4) 滿足 $f(x) \\le 0$ 的實數 $x$。" # Use \\le for LaTeX

    correct_answers = {}

    # (1) f(x) = 0: The roots are the x-intercepts
    if not roots:
        correct_answers["f(x)=0"] = r"$\emptyset$"
    else:
        roots_str = ", ".join([str(r) for r in roots])
        correct_answers["f(x)=0"] = f"$x = {roots_str}$"

    # Determine signs in intervals
    # The roots divide the x-axis into elementary intervals.
    # The sign flips at each distinct root. The sign for the rightmost interval
    # (roots[-1], +inf) is determined by the leading coefficient's sign.
    
    # Boundaries for intervals: [-inf, r1, r2, ..., rn, +inf]
    boundaries = [float('-inf')] + roots + [float('inf')]
    
    # List to store: (left_bound, right_bound, sign_in_interval)
    # Signs are calculated from right to left, then reversed for chronological order.
    intervals_with_signs = []
    current_sign_for_interval = leading_coeff_sign # Sign for the rightmost interval (rn, +inf)
    
    # Iterate from rightmost interval to leftmost
    for i in range(len(boundaries) - 1, 0, -1):
        left_b = boundaries[i-1]
        right_b = boundaries[i]
        
        # Only add valid open intervals
        if left_b < right_b:
            intervals_with_signs.append({'left': left_b, 'right': right_b, 'sign': current_sign_for_interval})
        
        current_sign_for_interval *= -1 # Sign flips when crossing a root
    intervals_with_signs.reverse() # Order intervals chronologically: (-inf, r1), (r1, r2), ...

    # Helper function to format intervals with open parentheses (for > and < conditions)
    def format_open_intervals(intervals_list):
        if not intervals_list:
            return r"$\emptyset$"
        
        formatted_parts = []
        for interval in intervals_list:
            left_str = r"-\infty" if interval['left'] == float('-inf') else str(interval['left'])
            right_str = r"\infty" if interval['right'] == float('inf') else str(interval['right'])
            formatted_parts.append(f"({left_str}, {right_str})")
        
        return r" \cup ".join(formatted_parts)

    # Helper function to format intervals with closed/open brackets (for >= and <= conditions),
    # merging contiguous segments.
    def format_leq_geq_intervals(segments_list):
        if not segments_list:
            return r"$\emptyset$"
        
        # Sort segments to ensure proper merging order
        segments_list.sort(key=lambda x: x['left'])

        merged_segments = []
        if segments_list:
            current_merge = segments_list[0]
            for i in range(1, len(segments_list)):
                next_segment = segments_list[i]
                
                # If the next segment's left bound is equal to or less than the current segment's right bound, merge them.
                # This covers cases like [1, 2] U [2, 3] -> [1, 3]
                if next_segment['left'] <= current_merge['right']:
                    current_merge['right'] = max(current_merge['right'], next_segment['right'])
                else:
                    merged_segments.append(current_merge)
                    current_merge = next_segment
            merged_segments.append(current_merge) # Add the last merged segment

        formatted_parts = []
        for segment in merged_segments:
            left_str = r"-\infty" if segment['left'] == float('-inf') else str(segment['left'])
            right_str = r"\infty" if segment['right'] == float('inf') else str(segment['right'])
            
            # Determine brackets based on infinity and whether it's an isolated point
            if segment['left'] == segment['right']: # Case for a single point, e.g., {0}
                 formatted_parts.append(f"{{{left_str}}}")
            else:
                left_bracket = '(' if segment['left'] == float('-inf') else '['
                right_bracket = ')' if segment['right'] == float('inf') else ']'
                formatted_parts.append(f"{left_bracket}{left_str}, {right_str}{right_bracket}")
        
        return r" \cup ".join(formatted_parts)

    # (2) f(x) > 0: Collect intervals where sign is +1
    positive_intervals_only = [i for i in intervals_with_signs if i['sign'] == 1]
    correct_answers["f(x)>0"] = f"${format_open_intervals(positive_intervals_only)}$"

    # (3) f(x) < 0: Collect intervals where sign is -1
    negative_intervals_only = [i for i in intervals_with_signs if i['sign'] == -1]
    correct_answers["f(x)<0"] = f"${format_open_intervals(negative_intervals_only)}$"

    # (4) f(x) <= 0: Collect negative intervals and include roots as closed boundaries.
    # This involves iterating through `intervals_with_signs` and `roots` to build contiguous segments.
    
    segments_for_le_0 = []
    
    current_idx = 0
    while current_idx < len(intervals_with_signs):
        interval = intervals_with_signs[current_idx]
        if interval['sign'] == -1: # This interval satisfies f(x) < 0
            current_left = interval['left']
            current_right = interval['right']
            
            # Look for contiguous negative intervals (considering roots as connecting points)
            next_idx = current_idx + 1
            while next_idx < len(intervals_with_signs):
                next_interval = intervals_with_signs[next_idx]
                # If next interval is also negative and it "touches" or starts where current ends
                if next_interval['sign'] == -1 and current_right == next_interval['left']:
                    current_right = next_interval['right']
                    next_idx += 1
                else:
                    break # Stop if next interval is positive or not contiguous
            
            segments_for_le_0.append({'left': current_left, 'right': current_right})
            current_idx = next_idx
        else:
            current_idx += 1 # Move to the next interval if current is positive

    correct_answers["f(x)<=0"] = f"${format_leq_geq_intervals(segments_for_le_0)}$"
    
    # Combine all individual answers into a single string for the 'answer' and 'correct_answer' fields.
    full_correct_answer_string = (
        f"1. {correct_answers['f(x)=0']}\n"
        f"2. {correct_answers['f(x)>0']}\n"
        f"3. {correct_answers['f(x)<0']}\n"
        f"4. {correct_answers['f(x)<=0']}"
    )
    
    return {
        "question_text": question_text,
        "answer": full_correct_answer_string, 
        "correct_answer": full_correct_answer_string,
        "sub_answers": correct_answers # Store granular answers for checking
    }

def normalize_interval_string(s):
    """
    Normalizes an interval string for robust comparison.
    Converts common user inputs (like 'inf', 'U') to the expected LaTeX format
    (`\\infty`, `\\cup`) and removes unnecessary spacing/LaTeX delimiters.
    """
    s = s.strip()
    s = s.replace(' ', '') # Remove all spaces
    s = s.replace('U', '\\cup') # Normalize union symbol
    s = s.replace('u', '\\cup') # Allow lowercase 'u'
    s = s.replace('inf', '\\infty') # Normalize infinity symbol
    s = s.replace('-inf', '-\\infty') # Normalize negative infinity
    s = s.replace('emptyset', '\\emptyset') # Normalize empty set
    s = s.replace('$', '') # Remove dollar signs from user input for internal comparison
    
    # Replace curly braces around single points, so '{0}' becomes '0' for easier comparison with root strings.
    # This might be re-added later for strict formatting, but not for comparison.
    s = re.sub(r'\{([-\d\.]+)\}', r'\1', s) 

    # Ensure consistent bracket usage around infinities
    s = s.replace(r'[-\infty', r'(-\infty') # [-inf, X] should be (-inf, X]
    s = s.replace(r'\infty]', r'\infty)')   # [X, inf] should be [X, inf)

    return s

def compare_interval_strings(user_s, correct_s):
    """
    Compares two interval strings after normalization.
    Handles potential variations in user input.
    """
    normalized_user = normalize_interval_string(user_s)
    normalized_correct = normalize_interval_string(correct_s)
    
    # Direct comparison after normalization
    return normalized_user == normalized_correct

def check(user_answer, correct_answer_obj):
    """
    檢查答案是否正確。
    user_answer: string, expected to be multiple lines, one for each sub-question.
    correct_answer_obj: The dict returned by generate, containing "sub_answers".
    """
    
    correct_sub_answers = correct_answer_obj["sub_answers"]
    
    # Split user's answer into lines and clean whitespace
    user_lines = [line.strip() for line in user_answer.strip().split('\n') if line.strip()]
    
    feedback = []
    is_correct_overall = True

    # Define regex patterns to extract the actual answer part,
    # allowing for optional question numbers (e.g., "1.") and variable prefixes (e.g., "x=").
    answer_patterns = {
        "f(x)=0": r'^\s*(\d+\s*\.\s*)?(\s*x\s*=\s*)?(.+)$',
        "f(x)>0": r'^\s*(\d+\s*\.\s*)?(\s*f\(x\)>0\s*:?\s*)?(.+)$',
        "f(x)<0": r'^\s*(\d+\s*\.\s*)?(\s*f\(x\)<0\s*:?\s*)?(.+)$',
        "f(x)<=0": r'^\s*(\d+\s*\.\s*)?(\s*f\(x\)\\le0\s*:?\s*)?(.+)$'
    }

    sub_question_keys = ["f(x)=0", "f(x)>0", "f(x)<0", "f(x)<=0"]
    
    for i, key in enumerate(sub_question_keys):
        try:
            user_input_line = user_lines[i]
            match = re.match(answer_patterns[key], user_input_line, re.IGNORECASE)
            
            user_ans_raw = match.group(3).strip() if match else "" # Extract the actual answer part
            
            if not user_ans_raw:
                 raise ValueError("User answer for this part is empty or not parsed correctly.")

            if key == "f(x)=0":
                # For roots, parse, convert to int, sort, and compare as lists.
                # Use lstrip('-').isdigit() to handle negative numbers.
                user_roots_str_list = re.split(r'[,;]\s*', user_ans_raw)
                user_roots = sorted([int(r.strip()) for r in user_roots_str_list if r.strip().lstrip('-').isdigit()])
                
                correct_roots_str = correct_sub_answers[key].replace('$x = ', '').replace('$', '').strip()
                correct_roots_list_str = re.split(r'[,;]\s*', correct_roots_str)
                correct_roots = sorted([int(r.strip()) for r in correct_roots_list_str if r.strip().lstrip('-').isdigit()])

                if user_roots == correct_roots:
                    feedback.append(f"{i+1}. $f(x)=0$ 的答案正確。")
                else:
                    feedback.append(f"{i+1}. $f(x)=0$ 的答案不正確。您的答案：${user_ans_raw}$，正確答案：{correct_sub_answers[key]}。")
                    is_correct_overall = False
            else: # For interval questions (>0, <0, <=0)
                if compare_interval_strings(user_ans_raw, correct_sub_answers[key]):
                    feedback.append(f"{i+1}. $f(x){key.replace('f(x)', '')}$ 的答案正確。") # e.g. f(x)>0 becomes $>0$
                else:
                    # For feedback, replace 'le' with '\le'
                    display_key = key.replace('le', '\\le') 
                    feedback.append(f"{i+1}. $f(x){display_key.replace('f(x)', '')}$ 的答案不正確。您的答案：${user_ans_raw}$，正確答案：{correct_sub_answers[key]}。")
                    is_correct_overall = False
                    
        except (IndexError, ValueError, AttributeError): # Handle missing lines, parsing errors, or no regex match
            display_key = key.replace('le', '\\le')
            feedback.append(f"{i+1}. $f(x){display_key.replace('f(x)', '')}$ 的答案格式不正確或缺失。正確答案：{correct_sub_answers[key]}。")
            is_correct_overall = False

    result_text = "<br>".join(feedback)
    
    return {"correct": is_correct_overall, "result": result_text, "next_question": True}