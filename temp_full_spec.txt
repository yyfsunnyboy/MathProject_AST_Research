DOMAIN_CAPSULE

```
domain: arithmetic

entities:
  - operand_base: rational
    constraints:
      - value_range: -50~50 (絕對值)
      - denominator_range: 2~20 (用於分數或混合數的分母)
      - non_zero: true
    notes: 此為數值基礎類型，在模板中會具體化為整數、分數、小數或混合數。
  - common_factor_base: rational
    constraints:
      - value_range: -100~100 (絕對值)
      - denominator_range: 1~10 (用於分數形式的公因數，分母為 1 則為整數)
      - non_zero: true
  - op_arithmetic: operator
    constraints:
      - allowed_values: ['+', '-', '*', '/']
  - op_distributive: operator
    constraints:
      - allowed_values: ['+', '-'] # 用於分配律中括號內的加減運算

operators:
  - +, -, *, /, sqrt, abs, ^, gcd, lcm, factorial, nCr, nPr # 列出常用運算，此題主要用到前四個

constraints:
  - 可計算性: 所有中間值與最終答案都必須「可精確計算」（使用 Python Fraction 或 int）。
  - 邊界:
    * 分數分母範圍: 2~20
    * 整數範圍: -100~100
    * 運算複雜度: 中間與最終答案的分子/分母絕對值不超過 4 位數（例: 9999/9999）。
  - 互斥:
    * 嚴禁除以零的情況。
    * 在「連續運算」模板中，必須至少包含一個分數或小數形式的運算數。
    * 在「分配律」模板中，必須至少包含一個混合數形式的運算數。
  - 最小複雜度:
    * 連續運算模板: 必須至少有 3 個運算數和 2 個運算符，且至少包含一次乘法或除法。
    * 分配律模板: 必須有 2 個運算數和 1 個公因數，且運算數必須是混合數。

templates:
  - name: chain_of_mixed_operations
    
    complexity_requirements: |
      - 必須生成 3 到 4 個運算數。
      - 必須生成 2 到 3 個運算符。
      - 至少一個運算符必須是乘法 (*) 或除法 (/)。
      - 運算數類型必須混合，至少包含一個分數或小數（非整數）。
      - 隨機引入括號，例如：無括號、左括號、右括號、內部括號（四個運算數時）。
      - 小數必須限於 1 或 2 位小數。
      
    variables:
      - num_operands: 隨機選取 (3 或 4)
      - operand_values: 列表，每個元素是 `operand_base` 類型，但隨機生成為：
          - 整數 (約佔 30%)：從 -50~50 隨機取，非零。
          - 真分數 (約佔 40%)：分子從 -49~49 隨機取，分母從 2~20 隨機取，非零，且分子絕對值小於分母。
          - 小數 (約佔 30%)：從 -10~10 隨機取，1 或 2 位小數，非零。
      - operators: 列表，`op_arithmetic` 類型，隨機選取，確保至少一個是乘法或除法。
      - parentheses_type: 隨機選取 ('none' | 'left_group' | 'right_group' | 'inner_group' (僅當 num_operands=4 時))
      
    construction: |
      1. 根據 `num_operands` 和 `operand_values` 的類型分佈生成對應數量的運算數。
         - 若為小數，需內部轉換為 Fraction 進行計算。
      2. 根據 `num_operands` 生成 `num_operands - 1` 個運算符，確保滿足乘除法要求。
      3. 根據 `parentheses_type` 和運算符優先級，使用 Python 運算符直接計算：
         例如，對於 `n1 op1 n2 op2 n3`：
         - `none`: result = n1 op1 n2 op2 n3 (依數學優先級)
         - `left_group`: temp = n1 op1 n2; result = temp op2 n3
         - `right_group`: temp = n2 op2 n3; result = n1 op1 temp
         - `inner_group` (若有 `n4`): temp = n2 op2 n3; result = n1 op1 temp op3 n4
         
         ⚠️ **重要**：所有運算都必須用 if-elif 判斷運算符，然後用 Python 的 +, -, *, / 直接計算。
         例如：
         ```
         if op1 == '+':
             temp = n1 + n2
         elif op1 == '-':
             temp = n1 - n2
         # ... 依此類推
         ```
      4. 確保在任何除法運算中，除數不為零。
      5. 將最終結果化簡到最簡分數形式。
      
    implementation_checklist: |
      工程師實作時必須確認：
      - [ ] 是否生成了正確數量的運算數和運算符。
      - [ ] 是否至少有一個分數或小數運算數。
      - [ ] 是否至少包含一個乘法或除法運算符。
      - [ ] 是否正確實現了括號結構邏輯。
      - [ ] 小數是否被正確轉換為分數進行計算。
      - [ ] 是否避免了除以零的情況。
      - [ ] 所有中間值和最終結果是否在指定複雜度範圍內。
    
    formatting:
      question_display: |
        純數學式，無中文敘述：
        1. 使用 `fmt_num(number_obj, display_as='auto', wrap_negative=True)` 格式化每個運算數。
           - `display_as='auto'` 會自動判斷顯示為分數、小數或整數。
           - `wrap_negative=True` 確保負數在乘除法中會被括號包起來 (例: `(-0.6)` 或 `(-\frac{3}{5})`)。
        2. 使用 `op_latex` 字典映射運算符（+ → +, - → -, * → \times, / → \div）。
        3. 根據 `parentheses_type` 添加括號。
        4. 使用 `clean_latex_output()` 包裝最終的 LaTeX 字串（自動加 `$` 符號）。
        
        ✅ **正確的組裝範例**：
        ```
        # 假設 n1, n2, n3, op1, op2 已生成
        # 假設 fmt_num 處理了負數括號和顯示類型
        if parentheses_type == 'left_group':
            q_str = f"({fmt_num(n1)} {op_latex[op1]} {fmt_num(n2)}) {op_latex[op2]} {fmt_num(n3)}"
        elif parentheses_type == 'right_group':
            q_str = f"{fmt_num(n1)} {op_latex[op1]} ({fmt_num(n2)} {op_latex[op2]} {fmt_num(n3)})"
        else: # none 或其他複雜結構
            # 必須考慮運算符優先級，例如先處理乘除
            q_str = f"{fmt_num(n1)} {op_latex[op1]} {fmt_num(n2)} {op_latex[op2]} {fmt_num(n3)}"
            # 需要更精細的邏輯來決定何時在沒有明確括號的情況下添加括號以表示優先級，
            # 例如，如果 op1 是 + 而 op2 是 *，則 n2 op2 n3 需要隱式括號或在結構上先計算。
            # 為了簡化，在此範例中，假設 fmt_num 和 op_latex 組合後，
            # 數學優先級已通過計算流程而非顯示括號體現。
        
        final_question_latex = clean_latex_output(q_str)
        ```
        
      answer_display: |
        純數字格式（方便文本框比對）：
        - 整數：`str(result)` → "42"
        - 分數：`str(result)` → "3/7"（Python Fraction 自動格式化為最簡分數）
        - 帶分數：`format_mixed_number_for_answer(result)` → "2 3/7" (當結果為假分數時)
        
        禁止：
        - 使用 LaTeX 格式（如 `\frac{3}{7}`）
        - 使用 `fmt_num(result)`（會產生 LaTeX）
    
    notes: |
      - 為了確保題目難度，特別要求混合運算數類型和乘除法。
      - 小數點位數限制是為了避免過於複雜的轉換。

  - name: distributive_property_application
    
    complexity_requirements: |
      - 必須包含 2 個混合數作為運算數。
      - 必須包含 1 個整數或分數作為公共因數。
      - 括號內的運算符必須是加法 (+) 或減法 (-)。
      - 最終計算結果應為整數或簡潔的分數。
      
    variables:
      - operand1: `operand_base` 類型，生成為混合數。
          - 整數部分: -10~10
          - 分數部分: 分子 1~19, 分母 2~20, 且分子 < 分母
      - operand2: `operand_base` 類型，生成為混合數。
          - 整數部分: -10~10
          - 分數部分: 分子 1~19, 分母 2~20, 且分子 < 分母
      - common_factor: `common_factor_base` 類型，生成為整數或分數。
      - inner_op: `op_distributive` 類型，隨機選取 ('+' 或 '-')。
      
    construction: |
      1. 生成 `operand1` 和 `operand2` 為混合數形式，並內部轉換為 Fraction。
      2. 生成 `common_factor`。
      3. 生成 `inner_op`。
      4. 依據題目形式，計算 `(operand1 inner_op operand2) * common_factor`。
         - 例如，如果 `inner_op` 是 `'-'`：`temp = operand1 - operand2`
         - 然後 `result = temp * common_factor`
         ⚠️ **重要**：所有運算都必須用 if-elif 判斷運算符，然後用 Python 的 +, -, *, / 直接計算。
      5. 確保中間和最終結果滿足複雜度要求。
      6. 將最終結果化簡到最簡分數形式。
      
    implementation_checklist: |
      工程師實作時必須確認：
      - [ ] 是否生成了 2 個混合數和 1 個公因數。
      - [ ] 混合數是否被正確轉換為分數進行計算。
      - [ ] 是否正確實現了分配律的計算邏輯。
      - [ ] 最終結果是否為整數或簡潔分數。
    
    formatting:
      question_display: |
        中文與數學式混合，但數學式必須在 LaTeX 中：
        1. 使用 `fmt_num(number_obj, display_as='mixed_number', wrap_negative=True)` 格式化 `operand1` 和 `operand2`。
           - `display_as='mixed_number'` 確保其顯示為帶分數形式（例: `3\frac{9}{11}`）。
           - `wrap_negative=True` 確保負數在乘除法中會被括號包起來。
        2. 使用 `fmt_num(common_factor_obj, display_as='auto', wrap_negative=True)` 格式化 `common_factor`。
        3. 使用 `op_latex` 字典映射運算符。
        4. 將組裝好的數學表達式用 `clean_latex_output()` 包裝，然後再與中文拼接。
        
        ✅ **正確的組裝範例**：
        ```
        # 假設 operand1_display, operand2_display 是 fmt_num(..., display_as='mixed_number') 的結果
        # 假設 common_factor_display 是 fmt_num(...) 的結果
        # 假設 inner_op_latex 是 op_latex[inner_op]
        # 假設 common_factor_op_latex 是 op_latex['*']
        
        math_expr = f"{operand1_display} {inner_op_latex} {operand2_display}"
        # 原題是 (A-B)*C，但顯示為 A*C - B*C。所以這裡的顯示方式需要注意。
        # 如果要顯示成原題的樣式：3 9/11×(-57 )-1 9/11×(-57 )
        q_str = (
            f"{fmt_num(operand1, display_as='mixed_number', wrap_negative=False)} {op_latex['*']} {fmt_num(common_factor, wrap_negative=True)} "
            f"{op_latex[inner_op]} {fmt_num(operand2, display_as='mixed_number', wrap_negative=False)} {op_latex['*']} {fmt_num(common_factor, wrap_negative=True)}"
        )
        
        # 如果要顯示成簡化後的樣式 (A-B)*C：
        # q_str = f"({fmt_num(operand1, display_as='mixed_number')} {op_latex[inner_op]} {fmt_num(operand2, display_as='mixed_number')}) {op_latex['*']} {fmt_num(common_factor)}"
        
        final_question_latex = clean_latex_output(q_str)
        question_text = f"計算下列各式的值。{final_question_latex}"
        ```
        
      answer_display: |
        純數字格式（方便文本框比對）：
        - 整數：`str(result)` → "42"
        - 分數：`str(result)` → "3/7"
        - 帶分數：`format_mixed_number_for_answer(result)` → "2 3/7"
        
        禁止：
        - 使用 LaTeX 格式
        - 使用 `fmt_num(result)`
    
    notes: |
      - 混合數和公因數的組合可以產生有趣的整數結果。
      - 確保 `(operand1 inner_op operand2)` 的結果不會過於複雜，以便後續乘法。

diversity:
  - 變異點 1 (數值類型): 在「連續運算」中，隨機組合整數、分數、小數。在「分配律」中，公因數可以是整數或分數。
  - 變異點 2 (運算符): 隨機選擇 `+`, `-`, `*`, `/`，但確保符合最小複雜度要求（例如，至少一個乘除）。
  - 變異點 3 (括號位置): 在「連續運算」中，隨機生成不同位置的括號，或無括號。
  - 變異點 4 (正負號): 運算數和公因數的正負號隨機變動。
  - 變異點 5 (數字大小): 數值範圍在指定邊界內隨機取樣，確保多樣性。
  - 退化檢查:
    *   避免生成 `0/X` 或 `X/0`。
    *   避免生成 `1 * X` 或 `X / 1` 導致運算數被移除的簡單情況。
    *   避免所有運算數都是整數的連續運算題。
    *   避免分配律中 `(A op B)` 結果為 0，除非這是刻意設計的簡單情況。
    *   避免所有運算數均為正數，確保負數的處理。

verifier:
  - 生成後應驗證：
    *   所有生成的數值是否符合其類型約束（範圍、分母、小數位數）。
    *   所有運算符是否在允許列表中。
    *   是否存在除以零的情況。
    *   最終答案是否為最簡分數形式。
    *   所有中間計算步驟的結果是否在指定的複雜度範圍內。
    *   是否滿足每個模板的 `complexity_requirements`。
    *   `question_display` 的 LaTeX 輸出是否能正確渲染（不包含中文在 `$` 內等）。
    *   `answer_display` 是否為純數字格式，不含 LaTeX。

cross_domain_tools:
  - safe_division(numerator, denominator): 執行安全的除法運算，返回 Fraction，避免除以零錯誤。
  - convert_decimal_to_fraction(decimal_value): 將浮點數小數轉換為 Fraction。
  - convert_mixed_to_fraction(whole_part, numerator, denominator): 將混合數的整數、分子、分母轉換為 Fraction。
  - format_mixed_number_for_display(fraction_obj): 將 Fraction 對象格式化為 LaTeX 帶分數顯示字串（例如 `3\frac{9}{11}`）。
  - format_mixed_number_for_answer(fraction_obj): 將 Fraction 對象格式化為純文本帶分數顯示字串（例如 `2 3/7`）。
  - fmt_num(number_obj, display_as='auto', wrap_negative=False): 格式化數字為 LaTeX 字串。
      - `display_as`: 'auto' (自動判斷), 'integer', 'fraction', 'decimal', 'mixed_number'。
      - `wrap_negative`: 布林值，若為 True 且數字為負數，則會用括號包起來 (例: `(-5)`)。
  - op_latex: 字典，將運算符字串映射到其 LaTeX 表示 (例: `{'*': '\\times', '/': '\\div'}`).
  - clean_latex_output(latex_str): 將給定的 LaTeX 數學表達式字串用 `$` 符號包裝，並處理常見的 LaTeX 顯示問題。
```